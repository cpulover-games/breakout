<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout</title>
</head>

<body>
    <canvas id="gameCanvas" height="500" width="500"></canvas>

    <script>
        // fundamental
        /** @type {HTMLCanvasElement} */ // declare type in VSCode (for code completion)
        var canvas;
        /** @type {CanvasRenderingContext2D} */
        var canvasContext;
        const FPS = 30;
        const BG_COLOR = "black";

        // ball
        var ballX = 100;
        var ballY = 400;
        var ballSpeedX = 7;
        var ballSpeedY = 7;
        const BALL_SIZE = 10;
        const BALL_COLOR = "white";

        // paddle
        var paddleX = 300;
        const PADDLE_WIDTH = 80;
        const PADDLE_THICKNESS = 10;
        const PADDLE_Y = 470;
        const PADDLE_COLOR = "white";

        // brick
        const BRICK_COLS = 10;
        const BRICK_ROWS = 7;
        var brickGrid = new Array(BRICK_COLS * BRICK_ROWS); // contains boolean for visibility
        const BRICK_WIDTH = 50;
        const BRICK_HEIGHT = 30;
        const BRICK_GAP = 3;
        const BRICK_COLOR = "blue";

        // mouse
        var mouseX;
        var mouseY;
        const TEXT_COLOR = "yellow";

        // setup script
        window.onload = function () {
            canvas = document.getElementById("gameCanvas");
            canvasContext = canvas.getContext("2d");

            setInterval(updateAll, 1000 / FPS); // invoke updateAll() fps times/second

            // events
            canvas.addEventListener('mousemove', updateMousePos);

            initGame();
        }

        /* INITIALIZATION */
        function initGame() {
            // init bricks
            for (i = 0; i < BRICK_COLS * BRICK_ROWS; i++) {
                if (Math.random() > 0.5) {
                    brickGrid[i] = true;
                } else {
                    brickGrid[i] = false;
                };
            }
        }

        function updateAll() {
            moveAll();
            drawAll();
            paddleBallCollision();
            brickBallCollision();
        }

        /* COLLISION */
        function paddleBallCollision() {
            var paddleTopEdgeY = PADDLE_Y;
            var paddleBottomEdgeY = paddleTopEdgeY + PADDLE_THICKNESS;
            var paddleLeftEdgeX = paddleX;
            var paddleRightEdgeX = paddleLeftEdgeX + PADDLE_WIDTH;
            var ballBottomPointY = ballY + BALL_SIZE;

            if (ballBottomPointY > paddleTopEdgeY && // below top of paddle
                ballBottomPointY < paddleBottomEdgeY && // above bottom of paddle
                ballX > paddleLeftEdgeX && // right of paddle left
                ballX < paddleRightEdgeX) { //left of paddle right

                // update Y-speed
                ballSpeedY *= -1;
                // update X-speed based on distance of centers between ball and paddle (X)
                var paddleCenterPointX = paddleX + PADDLE_WIDTH / 2;
                var paddleToBallCenter = ballX - paddleCenterPointX;
                ballSpeedX = paddleToBallCenter * 0.35;
            }
        }

        function brickBallCollision() {
            //indicate which col and row of brickGrid[] the ball are in
            var ballBrickCol = Math.floor(ballX / BRICK_WIDTH);
            var ballBrickRow = Math.floor(ballY / BRICK_HEIGHT);
            // convert to index array with col and row
            var brickIndexUnderBall = colRowToIndexArray(ballBrickCol, ballBrickRow);

            // boundaries of col and row
            if (ballBrickCol >= 0 && ballBrickCol < BRICK_COLS &&
                ballBrickRow >= 0 && ballBrickRow < BRICK_ROWS &&
                brickGrid[brickIndexUnderBall]) { // collision happens if brick is not hidden
                // hide the brick
                brickGrid[brickIndexUnderBall] = false;
                ballSpeedY *= -1;
            }

        }
        /* END OF COLLISION */

        /* DRAWING */
        function drawAll() {
            // big frame (draw every time to clear screen)
            colorRect(0, 0, canvas.width, canvas.height, BG_COLOR);

            // ball
            colorCircle(ballX, ballY, BALL_SIZE, BALL_COLOR);
            // paddle
            colorRect(paddleX, PADDLE_Y, PADDLE_WIDTH, PADDLE_THICKNESS, PADDLE_COLOR);
            // bricks
            drawBricks();
            // mouse position
            colorText(mouseX + ", " + mouseY, mouseX, mouseY, TEXT_COLOR);
        }

        /* EVENTS */
        function updateMousePos(event) {
            //???
            var rect = canvas.getBoundingClientRect();
            var root = document.documentElement;

            mouseX = event.clientX - rect.left - root.scrollLeft;
            mouseY = event.clientY - rect.top - root.scrollTop;

            paddleX = mouseX - PADDLE_WIDTH / 2; // center paddle
        }
        /* END OF EVENTS */

        /* DRAWING HELPERS */
        function colorRect(topX, topY, boxWidth, boxHeight, fillColor) {
            canvasContext.fillStyle = fillColor;
            canvasContext.fillRect(topX, topY, boxWidth, boxHeight);
        }

        function colorCircle(centerX, centerY, radius, fillColor) {
            canvasContext.fillStyle = fillColor;
            canvasContext.beginPath();
            canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
            canvasContext.fill();
        }

        function colorText(text, textX, textY, fillColor) {
            canvasContext.fillStyle = fillColor;
            canvasContext.fillText(text, textX, textY);
        }

        function drawBricks() {
            for (eachRow = 0; eachRow < BRICK_ROWS; eachRow++) {
                for (eachCol = 0; eachCol < BRICK_COLS; eachCol++) {
                    var indexArray = colRowToIndexArray(eachCol, eachRow);
                    if (brickGrid[indexArray]) {
                        colorRect(BRICK_WIDTH * eachCol, BRICK_HEIGHT * eachRow, BRICK_WIDTH - BRICK_GAP, BRICK_HEIGHT -
                            BRICK_GAP, BRICK_COLOR);
                    }
                }
            }
        }

        // convert to index of brickGrid[] when know its col and row
        function colRowToIndexArray(col, row) {
            return col + row * BRICK_COLS;
        }
        /* END OF DRAWING HELPERS */

        /* MOTION */
        function moveAll() {
            // update element position
            ballX += ballSpeedX;
            ballY += ballSpeedY;
            // boundations (collision with big frame)
            if (ballX < BALL_SIZE || ballX > canvas.width - BALL_SIZE) {
                ballSpeedX *= -1;
            }
            if (ballY < BALL_SIZE) {
                ballSpeedY *= -1;
            }
            /* GAME OVER */
            if (ballY > canvas.height - BALL_SIZE) {
                resetBall();
            }
        }

        /* GAME RESTART */
        function resetBall() {
            ballX = canvas.width / 2;
            ballY = canvas.height / 2;
            ballSpeedX = 7;
            ballSpeedY = 7;
        }
    </script>
</body>

</html>